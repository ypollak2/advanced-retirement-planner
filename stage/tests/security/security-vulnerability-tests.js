// Security Vulnerability Tests for Advanced Retirement Planner
// Tests for XSS, injection attacks, data security, and other vulnerabilities

const { TestFramework, createMock } = require('../utils/test-framework');
const puppeteer = require('puppeteer');
const path = require('path');
const testConfig = require('../config/test-config');

const test = new TestFramework();
test.configure({ timeout: 30000 });

// Security test patterns from config
const { xssPatterns, sqlInjectionPatterns, sensitiveDataPatterns } = testConfig.security;

test.describe('Security Vulnerability Tests', () => {
    let browser;
    let page;
    let consoleErrors = [];
    
    test.beforeAll(async () => {
        browser = await puppeteer.launch({
            headless: true,
            args: ['--no-sandbox', '--disable-setuid-sandbox']
        });
        page = await browser.newPage();
        
        // Capture console errors
        page.on('console', msg => {
            if (msg.type() === 'error') {
                consoleErrors.push(msg.text());
            }
        });
        
        // Monitor for XSS attempts
        await page.evaluateOnNewDocument(() => {
            window.xssAttempts = [];
            const originalAlert = window.alert;
            window.alert = (msg) => {
                window.xssAttempts.push(msg);
                console.error('XSS attempt detected:', msg);
            };
        });
        
        const indexPath = path.join(__dirname, '../../index.html');
        await page.goto(`file://${indexPath}`, { waitUntil: 'networkidle0' });
    });
    
    test.afterAll(async () => {
        if (browser) {
            await browser.close();
        }
    });
    
    test.describe('XSS Prevention', () => {
        test.it('should prevent XSS in text inputs', async () => {
            const textInputs = await page.$$('input[type="text"]');
            
            for (const input of textInputs) {
                for (const xssPattern of xssPatterns) {
                    await input.type(xssPattern);
                    await input.press('Enter');
                }
            }
            
            // Check if any XSS was executed
            const xssDetected = await page.evaluate(() => window.xssAttempts);
            test.expect(xssDetected).toHaveLength(0);
        });
        
        test.it('should prevent XSS in number inputs', async () => {
            const numberInputs = await page.$$('input[type="number"]');
            
            for (const input of numberInputs) {
                // Try to inject script via number input
                await page.evaluate((el, pattern) => {
                    el.value = pattern;
                    el.dispatchEvent(new Event('change', { bubbles: true }));
                }, input, '<script>alert("xss")</script>');
            }
            
            const xssDetected = await page.evaluate(() => window.xssAttempts);
            test.expect(xssDetected).toHaveLength(0);
        });
        
        test.it('should sanitize URL parameters', async () => {
            // Test with malicious URL parameters
            const maliciousUrl = `file://${path.join(__dirname, '../../index.html')}?name=<script>alert("xss")</script>&value="><img src=x onerror=alert("xss")>`;
            
            await page.goto(maliciousUrl, { waitUntil: 'networkidle0' });
            
            const xssDetected = await page.evaluate(() => window.xssAttempts);
            test.expect(xssDetected).toHaveLength(0);
        });
        
        test.it('should prevent XSS in localStorage data', async () => {
            // Inject malicious data into localStorage
            await page.evaluate((patterns) => {
                patterns.forEach((pattern, index) => {
                    localStorage.setItem(`xss-test-${index}`, pattern);
                });
                
                // Trigger app to read localStorage
                if (window.loadSavedData) {
                    window.loadSavedData();
                }
            }, xssPatterns);
            
            const xssDetected = await page.evaluate(() => window.xssAttempts);
            test.expect(xssDetected).toHaveLength(0);
            
            // Cleanup
            await page.evaluate(() => {
                Object.keys(localStorage).forEach(key => {
                    if (key.startsWith('xss-test-')) {
                        localStorage.removeItem(key);
                    }
                });
            });
        });
    });
    
    test.describe('Injection Attack Prevention', () => {
        test.it('should prevent SQL injection patterns', async () => {
            const inputs = await page.$$('input');
            
            for (const input of inputs.slice(0, 5)) { // Test first 5 inputs
                for (const sqlPattern of sqlInjectionPatterns) {
                    await input.click({ clickCount: 3 }); // Select all
                    await input.type(sqlPattern);
                    await input.press('Tab');
                }
            }
            
            // Check for any errors that might indicate SQL execution
            const errors = consoleErrors.filter(err => 
                err.toLowerCase().includes('sql') || 
                err.toLowerCase().includes('query') ||
                err.toLowerCase().includes('database')
            );
            
            test.expect(errors).toHaveLength(0);
        });
        
        test.it('should validate numeric inputs', async () => {
            const numericFields = [
                'currentAge', 'retirementAge', 'monthlySalary', 
                'currentSavings', 'monthlyExpenses'
            ];
            
            for (const fieldName of numericFields) {
                const isValid = await page.evaluate((field) => {
                    const input = document.querySelector(`[name="${field}"], #${field}`);
                    if (!input) return true; // Skip if field doesn't exist
                    
                    // Try various invalid inputs
                    const invalidInputs = [
                        'abc', '12.34.56', '1e308', '-Infinity', 
                        'NaN', '{{malicious}}', '${evil}'
                    ];
                    
                    for (const invalid of invalidInputs) {
                        input.value = invalid;
                        input.dispatchEvent(new Event('change', { bubbles: true }));
                        
                        // Check if value was sanitized
                        const parsed = parseFloat(input.value);
                        if (input.value !== '' && (isNaN(parsed) || !isFinite(parsed))) {
                            return false;
                        }
                    }
                    return true;
                }, fieldName);
                
                test.expect(isValid).toBe(true);
            }
        });
    });
    
    test.describe('Data Security', () => {
        test.it('should not expose sensitive data in DOM', async () => {
            // Check for sensitive data patterns in HTML
            const htmlContent = await page.content();
            
            for (const pattern of sensitiveDataPatterns) {
                const matches = htmlContent.match(pattern);
                if (matches) {
                    // Allow only in script tags (where they might be variable names)
                    const nonScriptMatches = matches.filter(match => {
                        const index = htmlContent.indexOf(match);
                        const beforeMatch = htmlContent.substring(Math.max(0, index - 50), index);
                        return !beforeMatch.includes('<script');
                    });
                    test.expect(nonScriptMatches).toHaveLength(0);
                }
            }
        });
        
        test.it('should not log sensitive data to console', async () => {
            // Intercept console logs
            const logs = await page.evaluate(() => {
                const consoleLogs = [];
                const methods = ['log', 'info', 'warn', 'error'];
                
                methods.forEach(method => {
                    const original = console[method];
                    console[method] = (...args) => {
                        consoleLogs.push({ method, args: args.map(String) });
                        original.apply(console, args);
                    };
                });
                
                // Trigger some calculations
                if (window.calculateRetirement) {
                    window.calculateRetirement({
                        password: 'secret123',
                        apiKey: 'abc-123-def',
                        monthlySalary: 10000
                    });
                }
                
                return consoleLogs;
            });
            
            // Check logs for sensitive patterns
            const sensitiveLogsFound = logs.filter(log => 
                sensitiveDataPatterns.some(pattern => 
                    log.args.some(arg => pattern.test(arg))
                )
            );
            
            test.expect(sensitiveLogsFound).toHaveLength(0);
        });
        
        test.it('should encrypt sensitive data in localStorage', async () => {
            const localStorageData = await page.evaluate(() => {
                const data = {};
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    data[key] = localStorage.getItem(key);
                }
                return data;
            });
            
            // Check for plaintext sensitive data
            Object.entries(localStorageData).forEach(([key, value]) => {
                // Skip checking cache keys
                if (key.includes('cache')) return;
                
                // Check for common sensitive patterns
                test.expect(value).not.toContain('password');
                test.expect(value).not.toContain('apiKey');
                test.expect(value).not.toContain('api_key');
                test.expect(value).not.toContain('secret');
                
                // Check for credit card patterns
                test.expect(value).not.toMatch(/\b\d{4}[\s-]?\d{4}[\s-]?\d{4}[\s-]?\d{4}\b/);
            });
        });
    });
    
    test.describe('CORS and External Resources', () => {
        test.it('should validate CORS proxy domain whitelist', async () => {
            const corsProxyUsage = await page.evaluate(() => {
                // Check if CORS proxy is used and has domain validation
                const scripts = Array.from(document.scripts);
                const corsProxyScripts = scripts.filter(s => 
                    s.textContent.includes('cors-anywhere') || 
                    s.textContent.includes('allorigins')
                );
                
                if (corsProxyScripts.length === 0) return { usesProxy: false };
                
                // Check for domain validation
                const hasDomainValidation = corsProxyScripts.some(s => 
                    s.textContent.includes('yahoo') || 
                    s.textContent.includes('domain') ||
                    s.textContent.includes('whitelist')
                );
                
                return {
                    usesProxy: true,
                    hasDomainValidation
                };
            });
            
            if (corsProxyUsage.usesProxy) {
                test.expect(corsProxyUsage.hasDomainValidation).toBe(true);
            }
        });
        
        test.it('should not load external scripts from untrusted sources', async () => {
            const externalScripts = await page.evaluate(() => {
                return Array.from(document.scripts)
                    .filter(s => s.src && !s.src.startsWith('file://'))
                    .map(s => s.src);
            });
            
            // Whitelist of allowed domains
            const trustedDomains = [
                'unpkg.com',
                'jsdelivr.net',
                'cdnjs.cloudflare.com',
                'googleapis.com',
                'gstatic.com'
            ];
            
            externalScripts.forEach(src => {
                const isTrusted = trustedDomains.some(domain => src.includes(domain));
                test.expect(isTrusted).toBe(true);
            });
        });
    });
    
    test.describe('Authentication and Session Security', () => {
        test.it('should clear sensitive data on logout/clear', async () => {
            // Simulate storing sensitive data
            await page.evaluate(() => {
                localStorage.setItem('userToken', 'abc123');
                localStorage.setItem('sessionId', 'xyz789');
                sessionStorage.setItem('tempAuth', 'temp123');
            });
            
            // Look for clear/logout functionality
            const clearButton = await page.$('button:contains("Clear"), button:contains("Reset")');
            if (clearButton) {
                await clearButton.click();
                
                // Confirm in dialog if it appears
                page.on('dialog', async dialog => {
                    await dialog.accept();
                });
                
                await page.waitForTimeout(1000);
            }
            
            // Check if sensitive data was cleared
            const remainingData = await page.evaluate(() => {
                return {
                    userToken: localStorage.getItem('userToken'),
                    sessionId: localStorage.getItem('sessionId'),
                    tempAuth: sessionStorage.getItem('tempAuth')
                };
            });
            
            if (clearButton) {
                test.expect(remainingData.userToken).toBe(null);
                test.expect(remainingData.sessionId).toBe(null);
            }
        });
        
        test.it('should implement secure headers recommendations', async () => {
            // Check for security-related meta tags
            const securityMeta = await page.evaluate(() => {
                const metas = {};
                document.querySelectorAll('meta').forEach(meta => {
                    if (meta.httpEquiv) {
                        metas[meta.httpEquiv] = meta.content;
                    }
                });
                return metas;
            });
            
            // Check for Content Security Policy
            if (securityMeta['Content-Security-Policy']) {
                test.expect(securityMeta['Content-Security-Policy']).toContain("default-src");
            }
            
            // Check for X-Content-Type-Options
            if (securityMeta['X-Content-Type-Options']) {
                test.expect(securityMeta['X-Content-Type-Options']).toBe('nosniff');
            }
        });
    });
    
    test.describe('Input Validation Security', () => {
        test.it('should validate file upload inputs if present', async () => {
            const fileInputs = await page.$$('input[type="file"]');
            
            for (const input of fileInputs) {
                const accepts = await page.evaluate(el => el.accept, input);
                if (accepts) {
                    // Should restrict file types
                    test.expect(accepts).not.toBe('*/*');
                    test.expect(accepts).not.toBe('');
                }
            }
        });
        
        test.it('should prevent prototype pollution', async () => {
            const isPolluted = await page.evaluate(() => {
                // Attempt prototype pollution
                const payload = '{"__proto__":{"polluted":"yes"}}';
                
                try {
                    // Try to pollute via JSON.parse
                    const parsed = JSON.parse(payload);
                    
                    // Check if prototype was polluted
                    const obj = {};
                    return obj.polluted === 'yes';
                } catch (e) {
                    return false;
                }
            });
            
            test.expect(isPolluted).toBe(false);
        });
    });
    
    test.describe('Security Report Generation', () => {
        test.it('should generate security audit report', async () => {
            const securityReport = {
                timestamp: new Date().toISOString(),
                xssTests: {
                    tested: xssPatterns.length,
                    prevented: xssPatterns.length - (await page.evaluate(() => window.xssAttempts?.length || 0))
                },
                injectionTests: {
                    tested: sqlInjectionPatterns.length,
                    prevented: sqlInjectionPatterns.length
                },
                consoleErrors: consoleErrors,
                recommendations: [
                    'Implement Content Security Policy headers',
                    'Add Subresource Integrity (SRI) for external scripts',
                    'Implement rate limiting for API calls',
                    'Add input validation on server side',
                    'Implement secure session management'
                ]
            };
            
            // Save security report
            const fs = require('fs');
            const reportPath = path.join(__dirname, '../../test-results/security-audit.json');
            fs.mkdirSync(path.dirname(reportPath), { recursive: true });
            fs.writeFileSync(reportPath, JSON.stringify(securityReport, null, 2));
            
            // Validate security passed
            test.expect(securityReport.xssTests.prevented).toBe(securityReport.xssTests.tested);
            test.expect(securityReport.injectionTests.prevented).toBe(securityReport.injectionTests.tested);
        });
    });
});

// Run the tests
test.run();