<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>E2E Test - Wizard Review Step Issues v7.5.1</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: #f0f2f5;
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 12px;
            margin-bottom: 30px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .header h1 {
            margin: 0 0 10px 0;
            font-size: 28px;
        }
        .header p {
            margin: 0;
            opacity: 0.9;
        }
        .controls {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }
        .btn {
            padding: 10px 20px;
            border-radius: 6px;
            border: none;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 500;
        }
        .btn-primary {
            background: #667eea;
            color: white;
        }
        .btn-primary:hover {
            background: #5a67d8;
            transform: translateY(-1px);
        }
        .btn-secondary {
            background: #e2e8f0;
            color: #2d3748;
        }
        .btn-secondary:hover {
            background: #cbd5e0;
        }
        .btn-success {
            background: #48bb78;
            color: white;
        }
        .btn-danger {
            background: #f56565;
            color: white;
        }
        .test-section {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        .test-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e2e8f0;
        }
        .test-title {
            font-size: 20px;
            font-weight: 600;
            color: #2d3748;
        }
        .test-status {
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 500;
        }
        .status-pass {
            background: #c6f6d5;
            color: #22543d;
        }
        .status-fail {
            background: #fed7d7;
            color: #742a2a;
        }
        .status-pending {
            background: #fefcbf;
            color: #744210;
        }
        .status-running {
            background: #bee3f8;
            color: #2c5282;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.6; }
            100% { opacity: 1; }
        }
        .test-details {
            margin-top: 15px;
        }
        .test-step {
            padding: 10px;
            margin: 5px 0;
            background: #f7fafc;
            border-left: 3px solid #e2e8f0;
            border-radius: 4px;
        }
        .test-step.success {
            border-left-color: #48bb78;
            background: #f0fff4;
        }
        .test-step.error {
            border-left-color: #f56565;
            background: #fff5f5;
        }
        .test-data {
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 13px;
            background: #f7fafc;
            padding: 15px;
            border-radius: 6px;
            margin-top: 10px;
            border: 1px solid #e2e8f0;
            overflow-x: auto;
        }
        .console-output {
            background: #1a202c;
            color: #e2e8f0;
            padding: 15px;
            border-radius: 6px;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
            margin-top: 20px;
        }
        .console-line {
            margin: 2px 0;
            white-space: pre-wrap;
        }
        .console-error { color: #fc8181; }
        .console-warn { color: #f6e05e; }
        .console-info { color: #63b3ed; }
        .console-success { color: #68d391; }
        .summary {
            background: linear-gradient(135deg, #f6f8fb 0%, #e9ecef 100%);
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            padding: 20px;
            margin-top: 30px;
        }
        .metric {
            display: inline-block;
            padding: 10px 20px;
            margin: 5px;
            background: white;
            border-radius: 6px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        .metric-label {
            font-size: 12px;
            color: #718096;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .metric-value {
            font-size: 24px;
            font-weight: 600;
            color: #2d3748;
        }
        .iframe-container {
            width: 100%;
            height: 800px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            overflow: hidden;
            margin-top: 20px;
            display: none;
        }
        iframe {
            width: 100%;
            height: 100%;
            border: none;
        }
        .progress-bar {
            width: 100%;
            height: 4px;
            background: #e2e8f0;
            border-radius: 2px;
            overflow: hidden;
            margin-top: 10px;
        }
        .progress-fill {
            height: 100%;
            background: #667eea;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üß™ E2E Test Suite - Wizard Review Step Issues</h1>
        <p>Testing v7.5.1 - Focus on WizardStepReview (Step 9) persistent issues</p>
    </div>

    <div class="controls">
        <button class="btn btn-primary" onclick="runAllTests()">üöÄ Run All Tests</button>
        <button class="btn btn-secondary" onclick="runProductionTests()">üåê Test Production</button>
        <button class="btn btn-secondary" onclick="runLocalTests()">üíª Test Local</button>
        <button class="btn btn-secondary" onclick="openTestApp()">üì± Open App</button>
        <button class="btn btn-secondary" onclick="clearConsole()">üßπ Clear Console</button>
        <button class="btn btn-danger" onclick="clearAllData()">üóëÔ∏è Clear All Data</button>
        <select id="testMode" style="padding: 8px; border-radius: 4px; border: 1px solid #e2e8f0;">
            <option value="couple">Couple Mode</option>
            <option value="individual">Individual Mode</option>
            <option value="both">Test Both Modes</option>
        </select>
    </div>

    <div id="test-container"></div>
    
    <div class="iframe-container" id="iframe-container">
        <iframe id="test-frame"></iframe>
    </div>

    <div class="console-output" id="console">
        <div class="console-line console-info">Console output will appear here...</div>
    </div>

    <div class="summary" id="summary" style="display:none;">
        <h3 style="margin-top: 0;">üìä Test Summary</h3>
        <div id="summary-metrics"></div>
        <div class="progress-bar">
            <div class="progress-fill" id="progress"></div>
        </div>
    </div>

    <script>
        // Test configuration
        const PRODUCTION_URL = 'https://ypollak2.github.io/advanced-retirement-planner/';
        const LOCAL_URL = 'http://localhost:8080/';
        let currentUrl = PRODUCTION_URL;
        let consoleLines = [];
        let testResults = [];

        // Comprehensive test data
        const testDataCouple = {
            // Step 1: Planning Type
            planningType: 'couple',
            
            // Step 2: Basic Information & Salary
            partner1Name: 'John Doe',
            partner2Name: 'Jane Doe',
            currentAge: 35,
            retirementAge: 67,
            partner1Salary: 25000,
            partner2Salary: 20000,
            partner1Bonus: 50000,  // Annual
            partner2Bonus: 30000,  // Annual
            partner1RSU: 60000,    // Quarterly
            partner2RSU: 45000,    // Quarterly
            partner1FreelanceIncome: 5000,
            partner2FreelanceIncome: 3000,
            
            // Step 3: Current Savings
            partner1CurrentPension: 150000,
            partner2CurrentPension: 100000,
            partner1CurrentTrainingFund: 80000,
            partner2CurrentTrainingFund: 60000,
            partner1PersonalPortfolio: 500000,
            partner2PersonalPortfolio: 300000,
            partner1RealEstate: 200000,
            partner2RealEstate: 150000,
            partner1Crypto: 50000,
            partner2Crypto: 30000,
            partner1BankAccount: 40000,
            partner2BankAccount: 25000,
            
            // Step 4: Contribution Rates
            partner1PensionEmployeeRate: 7,
            partner1PensionEmployerRate: 14.333,
            partner2PensionEmployeeRate: 6,
            partner2PensionEmployerRate: 14.333,
            partner1TrainingFundEmployeeRate: 2.5,
            partner1TrainingFundEmployerRate: 7.5,
            partner2TrainingFundEmployeeRate: 2.5,
            partner2TrainingFundEmployerRate: 7.5,
            
            // Step 5: Management Fees & Returns
            partner1PortfolioTaxRate: 25,
            partner2PortfolioTaxRate: 30,
            pensionReturn: 7,
            trainingFundReturn: 6.5,
            personalPortfolioReturn: 8,
            realEstateReturn: 6,
            cryptoReturn: 15,
            
            // Step 6: Investment Preferences
            riskTolerance: 'moderate',
            stockPercentage: 60,
            
            // Step 7: Partner Investments
            partner1RiskProfile: 'moderate',
            partner2RiskProfile: 'conservative',
            partner1ExpectedReturn: 7,
            partner2ExpectedReturn: 5,
            
            // Step 8: Goals & Expenses
            monthlyExpenses: 15000,
            emergencyFund: 65000,
            targetReplacement: 70,
            
            // Tax settings
            taxCountry: 'israel',
            country: 'israel'
        };

        const testDataIndividual = {
            planningType: 'individual',
            currentAge: 35,
            retirementAge: 67,
            currentMonthlySalary: 25000,
            annualBonus: 50000,
            quarterlyRSU: 60000,
            freelanceIncome: 5000,
            currentSavings: 150000,
            currentTrainingFund: 80000,
            currentPersonalPortfolio: 500000,
            currentRealEstate: 200000,
            currentCrypto: 50000,
            currentBankAccount: 40000,
            employeePensionRate: 7,
            employerPensionRate: 14.333,
            trainingFundEmployeeRate: 2.5,
            trainingFundEmployerRate: 7.5,
            personalPortfolioTaxRate: 25,
            pensionReturn: 7,
            trainingFundReturn: 6.5,
            personalPortfolioReturn: 8,
            realEstateReturn: 6,
            cryptoReturn: 15,
            riskTolerance: 'moderate',
            stockPercentage: 60,
            monthlyExpenses: 15000,
            emergencyFund: 40000,
            targetReplacement: 70,
            taxCountry: 'israel',
            country: 'israel'
        };

        // Test definitions
        const tests = [
            {
                id: 'retirement-projection',
                name: 'Retirement Projection Panel',
                description: 'Verify chart data generation and no "Missing data" errors',
                steps: [
                    'Navigate to Review step',
                    'Check if Retirement Projection Panel renders',
                    'Verify no "Missing data" message',
                    'Check chart data generation',
                    'Verify scenario projections'
                ],
                async test(frame, data) {
                    const results = [];
                    
                    // Check if panel exists
                    const hasPanel = await frame.evaluate(() => {
                        const panel = document.querySelector('.retirement-projection-panel, [id*="retirement-projection"]');
                        return !!panel;
                    });
                    results.push({ step: 'Panel exists', success: hasPanel });

                    // Check for missing data message
                    const hasMissingDataError = await frame.evaluate(() => {
                        const text = document.body.textContent;
                        return text.includes('Missing data for projection calculation');
                    });
                    results.push({ step: 'No missing data error', success: !hasMissingDataError });

                    // Check if chart data is generated
                    const chartData = await frame.evaluate(() => {
                        if (window.generateRetirementProjectionChart) {
                            const mockInputs = window.getAllInputs ? window.getAllInputs() : {};
                            const data = window.generateRetirementProjectionChart(mockInputs);
                            return {
                                exists: true,
                                hasData: Array.isArray(data) && data.length > 0,
                                dataLength: data ? data.length : 0,
                                sampleData: data && data.length > 0 ? data[data.length - 1] : null
                            };
                        }
                        return { exists: false };
                    });
                    results.push({ 
                        step: 'Chart data generation', 
                        success: chartData.exists && chartData.hasData,
                        data: chartData
                    });

                    // Check for projections display
                    const hasProjections = await frame.evaluate(() => {
                        const optimistic = document.querySelector('[class*="optimistic"], [id*="optimistic"]');
                        const realistic = document.querySelector('[class*="realistic"], [id*="realistic"]');
                        const conservative = document.querySelector('[class*="conservative"], [id*="conservative"]');
                        return {
                            optimistic: !!optimistic,
                            realistic: !!realistic,
                            conservative: !!conservative,
                            any: !!(optimistic || realistic || conservative)
                        };
                    });
                    results.push({ 
                        step: 'Scenario projections displayed', 
                        success: hasProjections.any,
                        data: hasProjections
                    });

                    return results;
                }
            },
            {
                id: 'component-scores',
                name: 'Component Scores Display',
                description: 'Verify total accumulation and monthly income show correct values',
                steps: [
                    'Navigate to Review step',
                    'Find Component Scores section',
                    'Check Total Accumulation value',
                    'Check Monthly Income value',
                    'Verify calculations are correct'
                ],
                async test(frame, data) {
                    const results = [];

                    // Find component scores section
                    const hasSection = await frame.evaluate(() => {
                        const section = document.querySelector('.component-scores, #component-scores, [class*="component-score"]');
                        return !!section;
                    });
                    results.push({ step: 'Component Scores section exists', success: hasSection });

                    // Check total accumulation
                    const accumulation = await frame.evaluate(() => {
                        const elements = Array.from(document.querySelectorAll('*')).filter(el => 
                            el.textContent.includes('Total Accumulation') || 
                            el.textContent.includes('◊¶◊ë◊ô◊®◊î ◊¶◊§◊ï◊ô◊î')
                        );
                        if (elements.length > 0) {
                            const parent = elements[0].parentElement || elements[0];
                            const text = parent.textContent;
                            const match = text.match(/[‚Ç™$]?([\d,]+)/);
                            return {
                                found: true,
                                value: match ? match[1].replace(/,/g, '') : '0',
                                fullText: text
                            };
                        }
                        return { found: false, value: '0' };
                    });
                    const accumulationValue = parseInt(accumulation.value);
                    results.push({ 
                        step: 'Total Accumulation displays value', 
                        success: accumulation.found && accumulationValue > 0,
                        data: { value: accumulationValue, text: accumulation.fullText }
                    });

                    // Check monthly income
                    const monthlyIncome = await frame.evaluate(() => {
                        const elements = Array.from(document.querySelectorAll('*')).filter(el => 
                            (el.textContent.includes('Monthly Income') || 
                             el.textContent.includes('◊î◊õ◊†◊°◊î ◊ó◊ï◊ì◊©◊ô◊™')) &&
                            !el.textContent.includes('Retirement Income')
                        );
                        if (elements.length > 0) {
                            const parent = elements[0].parentElement || elements[0];
                            const text = parent.textContent;
                            const match = text.match(/[‚Ç™$]?([\d,]+)/);
                            return {
                                found: true,
                                value: match ? match[1].replace(/,/g, '') : '0',
                                fullText: text
                            };
                        }
                        return { found: false, value: '0' };
                    });
                    const monthlyIncomeValue = parseInt(monthlyIncome.value);
                    results.push({ 
                        step: 'Monthly Income displays value', 
                        success: monthlyIncome.found && monthlyIncomeValue > 0,
                        data: { value: monthlyIncomeValue, text: monthlyIncome.fullText }
                    });

                    // Verify calculations
                    const calculations = await frame.evaluate(() => {
                        const inputs = window.getAllInputs ? window.getAllInputs() : {};
                        let expectedAccumulation = 0;
                        let expectedMonthlyIncome = 0;

                        if (inputs.planningType === 'couple') {
                            // Sum all savings
                            expectedAccumulation += parseFloat(inputs.partner1CurrentPension || 0);
                            expectedAccumulation += parseFloat(inputs.partner2CurrentPension || 0);
                            expectedAccumulation += parseFloat(inputs.partner1CurrentTrainingFund || 0);
                            expectedAccumulation += parseFloat(inputs.partner2CurrentTrainingFund || 0);
                            expectedAccumulation += parseFloat(inputs.partner1PersonalPortfolio || 0);
                            expectedAccumulation += parseFloat(inputs.partner2PersonalPortfolio || 0);
                            expectedAccumulation += parseFloat(inputs.partner1RealEstate || 0);
                            expectedAccumulation += parseFloat(inputs.partner2RealEstate || 0);
                            expectedAccumulation += parseFloat(inputs.partner1Crypto || 0);
                            expectedAccumulation += parseFloat(inputs.partner2Crypto || 0);

                            // Calculate monthly income
                            expectedMonthlyIncome += parseFloat(inputs.partner1Salary || 0);
                            expectedMonthlyIncome += parseFloat(inputs.partner2Salary || 0);
                            expectedMonthlyIncome += (parseFloat(inputs.partner1Bonus || 0) / 12);
                            expectedMonthlyIncome += (parseFloat(inputs.partner2Bonus || 0) / 12);
                            expectedMonthlyIncome += (parseFloat(inputs.partner1RSU || 0) / 3);
                            expectedMonthlyIncome += (parseFloat(inputs.partner2RSU || 0) / 3);
                        }

                        return {
                            expectedAccumulation: Math.round(expectedAccumulation),
                            expectedMonthlyIncome: Math.round(expectedMonthlyIncome),
                            inputs: {
                                planningType: inputs.planningType,
                                hasSalaryData: !!(inputs.partner1Salary || inputs.currentMonthlySalary)
                            }
                        };
                    });
                    
                    const accumulationCorrect = Math.abs(accumulationValue - calculations.expectedAccumulation) < 1000;
                    const incomeCorrect = Math.abs(monthlyIncomeValue - calculations.expectedMonthlyIncome) < 1000;
                    
                    results.push({ 
                        step: 'Calculations are correct', 
                        success: accumulationCorrect && incomeCorrect,
                        data: {
                            accumulation: { actual: accumulationValue, expected: calculations.expectedAccumulation },
                            income: { actual: monthlyIncomeValue, expected: calculations.expectedMonthlyIncome }
                        }
                    });

                    return results;
                }
            },
            {
                id: 'financial-health-score',
                name: 'Financial Health Score Components',
                description: 'Verify Savings Rate and Tax Efficiency show correct percentages',
                steps: [
                    'Navigate to Review step',
                    'Find Financial Health Score section',
                    'Check Savings Rate percentage',
                    'Check Tax Efficiency percentage',
                    'Verify overall score calculation'
                ],
                async test(frame, data) {
                    const results = [];

                    // Find financial health section
                    const hasSection = await frame.evaluate(() => {
                        const section = document.querySelector('[class*="financial-health"], #financial-health-score');
                        return !!section;
                    });
                    results.push({ step: 'Financial Health section exists', success: hasSection });

                    // Check Savings Rate
                    const savingsRate = await frame.evaluate(() => {
                        const elements = Array.from(document.querySelectorAll('*')).filter(el => 
                            el.textContent.includes('Savings Rate') || 
                            el.textContent.includes('◊©◊ô◊¢◊ï◊® ◊ó◊ô◊°◊õ◊ï◊ü')
                        );
                        if (elements.length > 0) {
                            const text = elements[0].closest('[class*="metric"], [class*="component"], div').textContent;
                            const match = text.match(/(\d+(?:\.\d+)?)\s*%/);
                            return {
                                found: true,
                                value: match ? parseFloat(match[1]) : 0,
                                fullText: text
                            };
                        }
                        return { found: false, value: 0 };
                    });
                    results.push({ 
                        step: 'Savings Rate shows percentage', 
                        success: savingsRate.found && savingsRate.value > 0,
                        data: { value: savingsRate.value, text: savingsRate.fullText }
                    });

                    // Check Tax Efficiency
                    const taxEfficiency = await frame.evaluate(() => {
                        const elements = Array.from(document.querySelectorAll('*')).filter(el => 
                            el.textContent.includes('Tax Efficiency') || 
                            el.textContent.includes('◊ô◊¢◊ô◊ú◊ï◊™ ◊û◊°')
                        );
                        if (elements.length > 0) {
                            const text = elements[0].closest('[class*="metric"], [class*="component"], div').textContent;
                            const match = text.match(/(\d+(?:\.\d+)?)\s*%/);
                            return {
                                found: true,
                                value: match ? parseFloat(match[1]) : 0,
                                fullText: text
                            };
                        }
                        return { found: false, value: 0 };
                    });
                    results.push({ 
                        step: 'Tax Efficiency shows percentage', 
                        success: taxEfficiency.found && taxEfficiency.value > 0,
                        data: { value: taxEfficiency.value, text: taxEfficiency.fullText }
                    });

                    // Check overall score
                    const overallScore = await frame.evaluate(() => {
                        const scoreElements = Array.from(document.querySelectorAll('[class*="total-score"], [class*="overall-score"], .text-4xl'));
                        for (const el of scoreElements) {
                            const match = el.textContent.match(/(\d+)/);
                            if (match && parseInt(match[1]) <= 100) {
                                return {
                                    found: true,
                                    value: parseInt(match[1]),
                                    element: el.className
                                };
                            }
                        }
                        return { found: false, value: 0 };
                    });
                    results.push({ 
                        step: 'Overall Financial Health Score', 
                        success: overallScore.found && overallScore.value > 0,
                        data: overallScore
                    });

                    // Verify calculations make sense
                    const calculationsValid = savingsRate.value > 0 && taxEfficiency.value > 0 && overallScore.value > 0;
                    results.push({ 
                        step: 'All score components calculated', 
                        success: calculationsValid,
                        data: {
                            savingsRate: savingsRate.value,
                            taxEfficiency: taxEfficiency.value,
                            overallScore: overallScore.value
                        }
                    });

                    return results;
                }
            },
            {
                id: 'portfolio-tax-reactivity',
                name: 'Portfolio Tax Calculation Reactivity',
                description: 'Verify tax calculations update when tax rate changes',
                steps: [
                    'Navigate to Savings step',
                    'Enter portfolio value',
                    'Change tax rate',
                    'Verify net value updates',
                    'Test in couple mode for both partners'
                ],
                async test(frame, data) {
                    const results = [];

                    // Navigate to savings step
                    await frame.evaluate(() => {
                        const savingsStep = document.querySelector('[data-step="3"], button:nth-child(3)');
                        if (savingsStep) savingsStep.click();
                    });
                    await new Promise(resolve => setTimeout(resolve, 1000));

                    // Test main portfolio tax calculation
                    const taxTest = await frame.evaluate(async () => {
                        const results = [];
                        
                        // Find portfolio input
                        const portfolioInput = document.querySelector('[name*="PersonalPortfolio"], #personalPortfolio');
                        const taxInput = document.querySelector('[name*="PortfolioTaxRate"], #portfolioTaxRate');
                        
                        if (portfolioInput && taxInput) {
                            // Set initial values
                            portfolioInput.value = '1000000';
                            portfolioInput.dispatchEvent(new Event('change', { bubbles: true }));
                            await new Promise(resolve => setTimeout(resolve, 500));
                            
                            // Set tax rate
                            taxInput.value = '25';
                            taxInput.dispatchEvent(new Event('change', { bubbles: true }));
                            await new Promise(resolve => setTimeout(resolve, 500));
                            
                            // Check net value
                            const netValueElement = document.querySelector('[class*="net-value"], [class*="after-tax"]');
                            const netValue1 = netValueElement ? netValueElement.textContent : '';
                            
                            // Change tax rate
                            taxInput.value = '30';
                            taxInput.dispatchEvent(new Event('change', { bubbles: true }));
                            await new Promise(resolve => setTimeout(resolve, 500));
                            
                            // Check if net value updated
                            const netValue2 = netValueElement ? netValueElement.textContent : '';
                            
                            results.push({
                                found: true,
                                taxRateChanged: true,
                                netValueUpdated: netValue1 !== netValue2,
                                values: { before: netValue1, after: netValue2 }
                            });
                        } else {
                            results.push({ found: false });
                        }
                        
                        return results;
                    });

                    results.push({ 
                        step: 'Portfolio tax calculation reactive', 
                        success: taxTest.length > 0 && taxTest[0].netValueUpdated,
                        data: taxTest[0]
                    });

                    // Test partner portfolios in couple mode
                    if (data.planningType === 'couple') {
                        const partnerTaxTest = await frame.evaluate(async () => {
                            const results = [];
                            
                            // Test Partner 1
                            const partner1Portfolio = document.querySelector('[name*="partner1PersonalPortfolio"]');
                            const partner1Tax = document.querySelector('[name*="partner1PortfolioTaxRate"]');
                            
                            if (partner1Portfolio && partner1Tax) {
                                partner1Portfolio.value = '500000';
                                partner1Portfolio.dispatchEvent(new Event('change', { bubbles: true }));
                                await new Promise(resolve => setTimeout(resolve, 500));
                                
                                const initialNetElements = document.querySelectorAll('[class*="net-value"]');
                                const initialNet = Array.from(initialNetElements).map(el => el.textContent);
                                
                                partner1Tax.value = '35';
                                partner1Tax.dispatchEvent(new Event('change', { bubbles: true }));
                                await new Promise(resolve => setTimeout(resolve, 500));
                                
                                const updatedNet = Array.from(initialNetElements).map(el => el.textContent);
                                const changed = initialNet.some((val, idx) => val !== updatedNet[idx]);
                                
                                results.push({
                                    partner: 1,
                                    found: true,
                                    updated: changed
                                });
                            }
                            
                            return results;
                        });

                        results.push({ 
                            step: 'Partner portfolio tax calculations reactive', 
                            success: partnerTaxTest.length > 0 && partnerTaxTest[0].updated,
                            data: partnerTaxTest
                        });
                    }

                    return results;
                }
            }
        ];

        // Helper functions
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const line = `[${timestamp}] ${message}`;
            consoleLines.push({ text: line, type });
            updateConsole();
        }

        function updateConsole() {
            const consoleEl = document.getElementById('console');
            consoleEl.innerHTML = consoleLines.map(line => 
                `<div class="console-line console-${line.type}">${line.text}</div>`
            ).join('');
            consoleEl.scrollTop = consoleEl.scrollHeight;
        }

        function clearConsole() {
            consoleLines = [];
            updateConsole();
        }

        function updateProgress(current, total) {
            const percent = (current / total) * 100;
            document.getElementById('progress').style.width = `${percent}%`;
        }

        async function navigateToReviewStep(frame) {
            log('Navigating to Review step...');
            
            // Try to find and click the review step
            const clicked = await frame.evaluate(() => {
                // Try different selectors
                const selectors = [
                    '[data-step="9"]',
                    'button:nth-child(9)',
                    'button:contains("Review")',
                    '[class*="step"]:last-child button',
                    '#wizard-step-9'
                ];
                
                for (const selector of selectors) {
                    const button = document.querySelector(selector);
                    if (button) {
                        button.click();
                        return true;
                    }
                }
                
                // If no direct button, try to navigate through steps
                const nextButtons = document.querySelectorAll('[class*="next"], button:contains("Next")');
                if (nextButtons.length > 0) {
                    nextButtons[nextButtons.length - 1].click();
                    return 'next';
                }
                
                return false;
            });
            
            if (clicked === 'next') {
                // Click through all steps
                for (let i = 0; i < 8; i++) {
                    await new Promise(resolve => setTimeout(resolve, 500));
                    await frame.evaluate(() => {
                        const next = document.querySelector('[class*="next"], button:contains("Next")');
                        if (next) next.click();
                    });
                }
            }
            
            await new Promise(resolve => setTimeout(resolve, 1000));
        }

        async function fillWizardData(frame, data) {
            log('Filling wizard with test data...');
            
            // Inject data into the app
            await frame.evaluate((testData) => {
                // Store data globally for the app to use
                window.testData = testData;
                
                // Try to set inputs directly if the app exposes a method
                if (window.setAllInputs) {
                    window.setAllInputs(testData);
                } else if (window.updateInputs) {
                    window.updateInputs(testData);
                } else {
                    // Fallback: try to trigger React state update
                    const event = new CustomEvent('updateTestData', { detail: testData });
                    document.dispatchEvent(event);
                }
                
                // Also try to update localStorage
                localStorage.setItem('retirementWizardInputs', JSON.stringify(testData));
            }, data);
            
            await new Promise(resolve => setTimeout(resolve, 1000));
        }

        async function runTest(test, data, environment) {
            const container = document.getElementById('test-container');
            
            // Create test section
            const section = document.createElement('div');
            section.className = 'test-section';
            section.innerHTML = `
                <div class="test-header">
                    <h3 class="test-title">${test.name}</h3>
                    <span class="test-status status-running">Running...</span>
                </div>
                <p>${test.description}</p>
                <div class="test-details" id="test-${test.id}-details"></div>
            `;
            container.appendChild(section);
            
            const detailsEl = document.getElementById(`test-${test.id}-details`);
            const statusEl = section.querySelector('.test-status');
            
            try {
                // Set up iframe
                const iframe = document.getElementById('test-frame');
                const iframeContainer = document.getElementById('iframe-container');
                
                log(`Loading ${environment} environment...`);
                iframe.src = currentUrl;
                iframeContainer.style.display = 'block';
                
                // Wait for load
                await new Promise((resolve, reject) => {
                    iframe.onload = resolve;
                    iframe.onerror = reject;
                    setTimeout(() => reject(new Error('Iframe load timeout')), 30000);
                });
                
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                // Fill data
                await fillWizardData(iframe.contentWindow, data);
                
                // Navigate to review step
                await navigateToReviewStep(iframe.contentWindow);
                
                // Run test
                log(`Running test: ${test.name}`);
                const results = await test.test(iframe.contentWindow, data);
                
                // Display results
                let allPassed = true;
                results.forEach(result => {
                    const stepEl = document.createElement('div');
                    stepEl.className = `test-step ${result.success ? 'success' : 'error'}`;
                    stepEl.innerHTML = `
                        <strong>${result.success ? '‚úÖ' : '‚ùå'} ${result.step}</strong>
                        ${result.data ? `<pre class="test-data">${JSON.stringify(result.data, null, 2)}</pre>` : ''}
                    `;
                    detailsEl.appendChild(stepEl);
                    
                    if (!result.success) allPassed = false;
                    log(`${result.step}: ${result.success ? 'PASS' : 'FAIL'}`, result.success ? 'success' : 'error');
                });
                
                // Update status
                statusEl.className = `test-status ${allPassed ? 'status-pass' : 'status-fail'}`;
                statusEl.textContent = allPassed ? 'PASSED' : 'FAILED';
                
                return { test: test.name, passed: allPassed, results };
                
            } catch (error) {
                log(`Test error: ${error.message}`, 'error');
                statusEl.className = 'test-status status-fail';
                statusEl.textContent = 'ERROR';
                
                const errorEl = document.createElement('div');
                errorEl.className = 'test-step error';
                errorEl.innerHTML = `<strong>‚ùå Error:</strong> ${error.message}`;
                detailsEl.appendChild(errorEl);
                
                return { test: test.name, passed: false, error: error.message };
            }
        }

        async function runAllTests() {
            const mode = document.getElementById('testMode').value;
            const container = document.getElementById('test-container');
            container.innerHTML = '';
            testResults = [];
            clearConsole();
            
            log('üöÄ Starting E2E test suite...', 'info');
            log(`Test mode: ${mode}`, 'info');
            log(`Environment: ${currentUrl}`, 'info');
            
            const testConfigs = [];
            if (mode === 'both' || mode === 'couple') {
                testConfigs.push({ data: testDataCouple, mode: 'couple' });
            }
            if (mode === 'both' || mode === 'individual') {
                testConfigs.push({ data: testDataIndividual, mode: 'individual' });
            }
            
            let totalTests = tests.length * testConfigs.length;
            let currentTest = 0;
            
            for (const config of testConfigs) {
                log(`\nüìã Testing ${config.mode} mode...`, 'info');
                
                for (const test of tests) {
                    currentTest++;
                    updateProgress(currentTest, totalTests);
                    
                    const result = await runTest(test, config.data, currentUrl.includes('localhost') ? 'local' : 'production');
                    testResults.push({ ...result, mode: config.mode });
                    
                    // Small delay between tests
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
            }
            
            // Show summary
            showSummary();
        }

        function showSummary() {
            const summary = document.getElementById('summary');
            const metrics = document.getElementById('summary-metrics');
            
            const total = testResults.length;
            const passed = testResults.filter(r => r.passed).length;
            const failed = total - passed;
            const successRate = total > 0 ? Math.round((passed / total) * 100) : 0;
            
            metrics.innerHTML = `
                <div class="metric">
                    <div class="metric-label">Total Tests</div>
                    <div class="metric-value">${total}</div>
                </div>
                <div class="metric">
                    <div class="metric-label">Passed</div>
                    <div class="metric-value" style="color: #48bb78;">${passed}</div>
                </div>
                <div class="metric">
                    <div class="metric-label">Failed</div>
                    <div class="metric-value" style="color: #f56565;">${failed}</div>
                </div>
                <div class="metric">
                    <div class="metric-label">Success Rate</div>
                    <div class="metric-value">${successRate}%</div>
                </div>
            `;
            
            summary.style.display = 'block';
            
            log(`\nüìä Test Summary: ${passed}/${total} passed (${successRate}%)`, passed === total ? 'success' : 'warn');
            
            // Log failed tests
            if (failed > 0) {
                log('\n‚ùå Failed tests:', 'error');
                testResults.filter(r => !r.passed).forEach(r => {
                    log(`  - ${r.test} (${r.mode} mode)`, 'error');
                });
            }
        }

        function runProductionTests() {
            currentUrl = PRODUCTION_URL;
            runAllTests();
        }

        function runLocalTests() {
            currentUrl = LOCAL_URL;
            runAllTests();
        }

        function openTestApp() {
            window.open(currentUrl, '_blank');
        }

        function clearAllData() {
            if (confirm('Clear all localStorage data?')) {
                localStorage.clear();
                log('‚úÖ All data cleared', 'success');
            }
        }

        // Initialize
        log('üß™ E2E Test Suite initialized', 'info');
        log('Ready to test Review step issues', 'info');
    </script>
</body>
</html>